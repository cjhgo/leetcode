
[toc]


### ch2基础知识

#### p12 矩阵中的路径
找到问题的递归公式:

find(bfce,i,j)
=finde(b,i,j)+[
  find(fce,上)||
  find(fce,下)||
  find(fce,左)||
  find(fce,右)||
]

## ch4解决面试题的思路

### ch4.1分解让复杂问题简单化
#### p36,二叉搜索树与双向链表
对应于
leetcode426
convert-binary-search-tree-to-sorted-doubly-linked-list


问题分析:
二叉树和双向链表的结构其实是一样的,都是由一个数据成员和两个指针构成.
不过,在二叉搜索树中,TreeNode的left,right指向左右子结点
而在BST对应的双向链表中ListNode的pre,next分别指向左子树对应双向链表的尾,右子树对应的双向链表的头

定义函数,`void conv(TreeNode* root,TreeNode*& head, TreeNode* tail)`
把root指向的BST转换为双向链表,通过head,tail返回转换后的双向链表的头尾指针
那么,问题就可以递归的解决掉.
把root指向的BST转换为双向链表的算法步骤


1. 把左子树转换为双向链表,返回头尾lhead,ltail
2. 把右子树转换为双向链表,返回头尾rhead,rtail
3. 修改root->left=ltail,root->right=rhead
修改接收指针,head=lhead,tail=ltail


问题拓展
108	Convert Sorted Array to Binary Search Tree    
		
109	Convert Sorted List to Binary Search Tree    
538	Convert BST to Greater Tree    

## ch5优化时间和空间效率

### ch5.2优化时间效率

由于用户对响应时间更敏感,以及内存一般是充足的
因此一般而言,算法的时间复杂度要比空间复杂度重要.


**背景知识:我们有成熟的时间复杂度为O(n)的算法得到数组中任意第k大的数字,   
借鉴快排中的partition函数**



#### p39 数组中出现次数超过一般的数字
问题描述: 数组中有一个数字出现次数超过数组长度一半,找出这个数

这个数就是中位数,详见"找中位数算法"的相关讨论

+ 解法1:基于partition的O(n)算法
需要修改数组
+ 解法2: 加一,减一


#### p40 最小的k个数
问题描述: 输入n个数,输出最小的k个数


+ 解法1,排序取 [:k], o(nlogn)
+ 解法2,基于partition的o(n)算法
需要修改数组
+ 解法3,用size为k的容器保存最小的k个数,o(nlogk)
每来一个数,和k个数中最大的比,如果比最大的小,那它一定属于最小的k个数


相关问题 find kth 问题
#### p41 数据流中的中位数
问题描述:从动态的数据流中求得中位数

+ 解法1,无序的数组
+ 解法2,排序的数组
+ 解法3,排序的链表
+ 解法4,二叉搜索树->AVL树
+ 解法5,最大堆+最小堆
中位数只需要满足左边的都比它小,右边的都比它大即可
因此,只要把数据流中已读取数字的
*左半部分维护为大根堆,右半部分维护为小根堆,
并且满足,left top < right top*
那么即可在常数时间内获取中位数;每新读取一个元素,只要维持以下这两点即可:
  - 左右两堆元素数目相等或相差为1
  通过`新来元素依次插入到左右(或右左)`即可满足
  - 左边最大 小于 右边最小
  插入左边时检查new是否会取代top,
  如果不取代那么仍然满足,直接插入即可,如果会取代那么先把new插入到右边然后把右边的最小值插入到左边
  插入右边时执行的检查同理


相关问题

从海量数据中找中位数等等

#### p42 连续子数组的最大和
问题描述: 输入一个整型数组,其中既有正数也有负数,
在O(n)的时间复杂度内求所有连续子数组的和的最大值.

+ 解法1:
+ 解法2:动态规划
#### p43 1-n整数中1出现的次数?
没看懂...
#### p44 数字序列中某一位的数字
总结规律
#### p45 把数组排成最小的数?
没看懂
#### p46 把数字翻译成字符串
递归回溯
#### p47 礼物的最大价值

#### p48 最长不含重复字符的子字符串

### ch5.3时间效率与空间效率的平衡

#### p49 丑数
#### p50 第一个只出现一次的字符
#### p51 数组中的逆序对
#### p52 两个链表的第一个公共节点
leetcode160#easy
https://leetcode.com/problems/intersection-of-two-linked-lists/description/

问题分析:
普通的单向链表;
两个单向链表的公共节点指的是,从某一节点开始,它们的next指针
指向同一个节点,所以很自然的,从公共节点之后,两个链表是重合的
值是相同的,地址也是相同的,看起来像是一个Y形.
在公共节点之前,两个单向链表也有可能值是相等的,但并不是同一个链表.


问题的解法:

1. 最暴力的方法自然是两重for-loop,其时间复杂度是$O(m*n),相等于O(n^2)$

2. 基于hashtable的解法,用空间换时间
遍历第一个链表,用hashtable存一下,这样可以O(1)的判断某个值在不在第一个链表中
然后顺序遍历另一个链表,第一个在hashtable中的就是要找的公共节点
(由于结点间的值可以重复,所以hash要对Node地址,而不是node.val)
$T:m+n;S:max(m,n)$
3. 基于栈的解法,用空间换时间
遍历链表存到栈中,栈后入先出,
这样公共节点会从存放两个链表的栈顶挨个pop
$T:m+n;S:m+n$
4. 基于双指针的解法,更高效的算法
从公共节点开始,两个链表是重合的
那么通过链表长度差k我们可以得知
从长链表的头指针开始,先走k步,然后和短链表齐步走
二者会同时遇到第一个公共节点
$T:m+n;S:1$

#### p68树中两个节点的最低公共祖先

leetcode 235 树是一个BST
leetcode 236 树是一个普通的树



问题描述:
给定一棵树,求指定两个节点的最低公共祖先

问题分析:

情况1:如果这棵树是一个BST,二叉搜索树

BST什么特点
`左子树<root<右子树 <=>` 
`if val <root then val 在左子树;`
`if val > root then val 在右子树`

然后,两个节点一定分别在最低公共祖先的左右子树上.
即,如果比当前节点都大,或者都小,那么两个节点一定在当前节点的同一侧子树上
当前节点一定不是最低公共祖先
判断找到最低公共祖先的条件是:
两个节点不在当前节点的同一侧了
```
< < 同在右侧, cur=cur->right
< >
< =
> <
> > 同在左侧, cur=cur->left
> =
```

情况2:这棵树是一棵普通的树,但是每个节点有一个指向父亲节点的parent指针

这种情况下,我们可以通过parent指针,得到一个从指定节点到root的链表
然后问题就变成了找到两个呈`Y`形关系的链表之间的第一个公共节点的问题
(由于后边的节点是重合的,因此无法通过倒置链表的方法来处理)
可以通过双指针法,找到第一个公共节点

情况3:就是一棵普通的树,没有任何其他特殊的性质,怎么做?

深度优先遍历,同时记录下遍历到每个节点的路径
然后再对存储的路径进行比较就可以了.
